# flake8: noqa

# This file has been checked to be mypy compliant, other than the use of
# _TypedDictMeta, and unpacking behaviour of types that work but mypy doesn't like.
# type: ignore

import json
import re
from pathlib import Path
from typing import (
    Any,
    Dict,
    Optional,
    Type,
    _TypedDictMeta,
    get_args,
    get_origin,
)

from event_model import SCHEMA_PATH
from event_model.documents import (
    Datum,
    DatumPage,
    Event,
    EventDescriptor,
    EventPage,
    Resource,
    RunStart,
    RunStop,
    StreamDatum,
    StreamResource,
)
from event_model.documents._type_wrapper import extra_schema
from pydantic import BaseConfig, BaseModel, Extra, Field, create_model
from typing_extensions import NotRequired, Annotated

SCHEMA_OUT_DIR = Path("event_model") / SCHEMA_PATH


# Used to add user written schema to autogenerated schema.
def merge_dicts(dict1: dict, dict2: dict) -> dict:
    """
    Takes two dictionaries with subdirectories and returns a new dictionary of the two merged:
    dict1 = {
        "x1": {
            "y1": 0,  "y3": {"z1" : [1, 2], "z2": 1}
        },
        "x2" : 0,
        "x3": 1
    }
    and
    dict2 = {
        "x1": {
            "y2" : 0,  "y3": {"z1": [3, 4], "z3": 5}
        },
        "x3" : 0
    }
    returns
    {
        "x1": {
            "y1": 0, "y2": 0,  "y3": {"z1": [1, 2, 3, 4], "z2": 1, "z3": 5}
        },
        "x2": 0
        "x3": 1
    }
    """

    return_dict = dict2.copy()

    for key in dict1:
        if key not in dict2:
            return_dict[key] = dict1[key]

        elif not isinstance(dict1[key], type(dict2[key])):
            return_dict[key] = dict1[key]

        elif isinstance(dict1[key], dict):
            return_dict[key] = merge_dicts(dict1[key], dict2[key])

        elif isinstance(dict1[key], list):
            return_dict[key] = dict1[key] + dict2[key]

    return return_dict


def is_notrequired(field):
    """
    Checks if a field is of type `NotRequired[x]`.
    """

    return get_origin(field) is NotRequired


def is_annotated(field):
    """
    Checks if a field is of type `T[Annotated[x, y]]`.
    """

    return get_origin(get_args(field)[0]) is Annotated


def change_type_to_pydantic_acceptable(field):
    """
    Converts a field from type `NotRequired[Annotated[x, y]]`
    or `NotRequired[x]`, to `Annotated[Optional[x], y]`.

    mypy requires NotRequired has to be outside the Annotated type:
    `NotRequired[Annotated[...]]`, however pydantic requireds `Optional` instead
    of `NotRequired`, and `Optional` has to be inside the `Annotated` block.

    Additionally, pydantic will understand a field with type `Annotated[Optional[x], ...]` is
    optional and take it out of the `required` list in the generated schema,
    however a field with type `Optional[x]` will not be removed from `required`
    in the schema, this function will add a blank `Annotated` if one is not
    present on the `NotRequired` field.
    """
    assert get_origin(field) == NotRequired
    if is_annotated(field):
        annotated = get_args(field)[0]
        t, field, *extra = get_args(annotated)
    else:
        t = get_args(field)
        assert len(t) == 1
        t, field = t[0], Field()

    return Annotated[Optional[t], field]


def swap_typeddict_inside_annotation(field: type):
    origin = get_origin(field)
    args = get_args(field)

    # In the case we have a field with type TypedDict but no annotations
    if not args and isinstance(origin, _TypedDictMeta):
        return swap_all_annotations(origin)

    for index, arg in enumerate(args):
        if isinstance(arg, _TypedDictMeta):
            arg = *args[:index], swap_all_annotations(arg), *args[(index + 1) :]
            return origin[arg]
        else:
            sub_swap = swap_typeddict_inside_annotation(arg)
            if sub_swap:
                args = (
                    *args[:index],
                    sub_swap,
                    *args[(index + 1) :],
                )
                return origin[args]

    return None


def swap_all_annotations(typed_dict: _TypedDictMeta):
    """
    Annotation[] and Optional[] need to be swapped around if type checking is
    False. This function will take a TypedDictMeta and swap all instances of
    Optional and Annotation, and will also do this with any typeddict referenced.
    """
    new_annotations = {}

    for name, field in typed_dict.__annotations__.items():
        if is_notrequired(field):
            field = change_type_to_pydantic_acceptable(field)
        new_annotations[name] = field
        swapped_typeddict_annotation = swap_typeddict_inside_annotation(field)
        if swapped_typeddict_annotation:
            new_annotations[name] = swapped_typeddict_annotation
    typed_dict.__annotations__ = new_annotations

    return typed_dict


class Config(BaseConfig):
    """
    Config for generated BaseModel.
    """

    extra = Extra.forbid

    def alias_generator(string_to_be_aliased):
        """
        Alias in snake case
        """
        return re.sub(r"(?<!^)(?=[A-Z])", "_", string_to_be_aliased).lower()


# From https://github.com/pydantic/pydantic/issues/760#issuecomment-589708485
def parse_typeddict_to_schema(
    typed_dict: Any,
    out_dir: Optional[Path] = None,
) -> Type[BaseModel]:
    annotations: Dict[str, Any] = {}

    typed_dict = swap_all_annotations(typed_dict)

    for name, field in typed_dict.__annotations__.items():
        default_value = getattr(typed_dict, name, ...)
        annotations[name] = (field, default_value)

    model = create_model(typed_dict.__name__, __config__=Config, **annotations)

    # Docstring is used as the description field.
    model.__doc__ = typed_dict.__doc__

    # title goes to snake_case
    model.__name__ = Config.alias_generator(typed_dict.__name__).lower()
    model_schema = model.schema(by_alias=True)

    model_schema["description"] = typed_dict.__doc__

    # Add the manually defined extra stuff
    if typed_dict in extra_schema:
        model_schema = merge_dicts(extra_schema[typed_dict], model_schema)

    if out_dir:
        with open(out_dir / f'{model_schema["title"]}.json', "w+") as f:
            json.dump(model_schema, f, indent=3)

    return model_schema


def generate_all_schema(schema_out_dir: Path = SCHEMA_OUT_DIR) -> None:
    parse_typeddict_to_schema(DatumPage, out_dir=schema_out_dir)
    parse_typeddict_to_schema(Datum, out_dir=schema_out_dir)
    parse_typeddict_to_schema(EventDescriptor, out_dir=schema_out_dir)
    parse_typeddict_to_schema(EventPage, out_dir=schema_out_dir)
    parse_typeddict_to_schema(Event, out_dir=schema_out_dir)
    parse_typeddict_to_schema(Resource, out_dir=schema_out_dir)
    parse_typeddict_to_schema(RunStart, out_dir=schema_out_dir)
    parse_typeddict_to_schema(RunStop, out_dir=schema_out_dir)
    parse_typeddict_to_schema(StreamDatum, out_dir=schema_out_dir)
    parse_typeddict_to_schema(StreamResource, out_dir=schema_out_dir)


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument("--schema_out_directory", default=SCHEMA_OUT_DIR, nargs="?")
    args = parser.parse_args()
    generate_all_schema(schema_out_dir=args.schema_out_directory)
